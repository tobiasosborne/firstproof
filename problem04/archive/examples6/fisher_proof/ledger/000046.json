{"type":"node_created","timestamp":"2026-02-08T10:05:10.916184187Z","node":{"id":"1.1.5","type":"claim","statement":"DEFINITION 0.4 (Discrete Hilbert transform H_p). Let p in P_n with roots(p) = (lambda_1, ..., lambda_n). For each index i in {1, ..., n}, define H_p(lambda_i) := sum_{j=1, j!=i}^n 1/(lambda_i - lambda_j). This is well-defined because lambda_i != lambda_j for all j != i (since roots are distinct). EQUIVALENT FORMULA: H_p(lambda_i) = p\"(lambda_i) / (2 p(lambda_i)). PROOF: Step 1. Since p(x) = prod_{j=1}^n (x - lambda_j), differentiating gives p(x) = sum_{j=1}^n prod_{m!=j} (x - lambda_m). Evaluating at x = lambda_i: p(lambda_i) = prod_{m!=i} (lambda_i - lambda_m) != 0. Step 2. Differentiate p(x)/p(x) = sum_{j=1}^n 1/(x - lambda_j) to get [p\"(x)p(x) - (p(x))^2] / p(x)^2 = -sum_{j=1}^n 1/(x - lambda_j)^2. Step 3. Multiply the identity p(x) = p(x) * sum_{j=1}^n 1/(x - lambda_j) by both sides and differentiate: p\"(x) = p(x) * sum_j 1/(x - lambda_j) + p(x) * (-sum_j 1/(x - lambda_j)^2). At x = lambda_i, p(lambda_i) = 0, so p\"(lambda_i) = p(lambda_i) * sum_{j=1}^n 1/(lambda_i - lambda_j). The j = i term: lim_{x-\u003elambda_i} p(x)/(x - lambda_i)^2 = lim_{x-\u003elambda_i} prod_{m!=i}(x - lambda_m) / (x - lambda_i) = 0 by L Hopital (numerator -\u003e p(lambda_i) != 0, denominator -\u003e 0 is wrong; more carefully: p(x) = (x-lambda_i) prod_{m!=i}(x-lambda_m), so p(x)/(x-lambda_i)^2 = prod_{m!=i}(x-lambda_m)/(x-lambda_i) -\u003e 0 since numerator is finite and denominator -\u003e 0 is wrong again). CORRECT DERIVATION: p(x) = p(x) sum_j 1/(x-lambda_j). So p\"(x) = p\"(x) sum_j 1/(x-lambda_j) + p(x) d/dx[sum_j 1/(x-lambda_j)] + p(x) sum_j 1/(x-lambda_j) (from product rule on p*sum, not p*sum). Actually: p\"(x) = d/dx[p(x) sum_j 1/(x-lambda_j)] = p\"(x) sum_j 1/(x-lambda_j) + p(x) sum_j (-1/(x-lambda_j)^2). This is wrong: p\"(x) means the second derivative. Let f(x) = p(x)/p(x) = sum_j 1/(x-lambda_j). Then p(x) = p(x) f(x), so p\"(x) = p\"(x)f(x) + p(x)f(x). At x = lambda_i: p(lambda_i) = 0, p(lambda_i) = prod_{m!=i}(lambda_i - lambda_m), f(lambda_i) has a pole. Instead use: f(x) = 1/(x-lambda_i) + g_i(x) where g_i(x) = sum_{j!=i} 1/(x-lambda_j) is regular at lambda_i with g_i(lambda_i) = H_p(lambda_i). Then p = pf gives p = p(1/(x-lambda_i) + g_i). So p(x)(x-lambda_i) = p(x) + p(x)(x-lambda_i)g_i(x). Let h(x) = p(x)/(x-lambda_i) = prod_{m!=i}(x-lambda_m). Then p(x) = h(x) + (x-lambda_i)h(x)g_i(x), and p\"(x) = h(x) + h(x)g_i(x) + [(x-lambda_i)h(x)g_i(x)]. At x = lambda_i: p\"(lambda_i) = h(lambda_i) + h(lambda_i)g_i(lambda_i) = 2 p(lambda_i) H_p(lambda_i). Hence H_p(lambda_i) = p\"(lambda_i)/(2p(lambda_i)). LAURENT EXPANSION INTERPRETATION: nG_p(z) = sum_{j=1}^n 1/(z - lambda_j) = 1/(z - lambda_i) + H_p(lambda_i) + O(z - lambda_i) as z -\u003e lambda_i. That is, H_p(lambda_i) is the constant term in the Laurent expansion of nG_p(z) about the simple pole z = lambda_i.","inference":"assumption","workflow_state":"available","epistemic_state":"pending","taint_state":"unresolved","content_hash":"3570f1da305d2b7bd44011d39041b098a95b5b6d3083e8b0297e28bfe3b878bd","created":"2026-02-08T10:05:10.916179607Z","claimed_at":"0001-01-01T00:00:00Z"}}