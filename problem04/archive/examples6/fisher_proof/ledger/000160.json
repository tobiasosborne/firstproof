{"type":"node_created","timestamp":"2026-02-08T10:19:21.290896725Z","node":{"id":"1.5.2.6","type":"claim","statement":"ARGUMENT PRINCIPLE ON C^+ GIVES EXACTLY 1 ROOT. Apply the argument principle to f(w) = p'(w) - nc p(w) on the contour Gamma_R = [-R, R] union {R e^{i theta} : theta in [0, pi]} (upper semicircle), oriented counterclockwise, for R sufficiently large. The number of zeros of f inside Gamma_R (i.e., in the upper half-disk, approximating C^+) equals (1/(2 pi i)) integral_{Gamma_R} f'(w)/f(w) dw = (1/(2 pi)) Delta_{Gamma_R} arg(f). COMPUTATION: (I) On the semicircular arc |w| = R, theta in [0, pi]: f(w) = (-nc) w^n (1 + O(1/w)), so arg(f(Re^{i theta})) approx arg(-nc) + n theta. As theta goes from 0 to pi, the argument increases by n pi. Contribution: n pi / (2 pi) = n/2. (II) On the real segment [-R, R]: f(x) = p'(x) - nc p(x) = [p'(x) - Re(nc) p(x)] - i Im(nc) p(x). Write f(x) = A(x) + i B(x) where A(x) = p'(x) - Re(nc) p(x) and B(x) = -Im(nc) p(x). Since Im(nc) \u003c 0 (because Im(c) \u003c 0), we have -Im(nc) \u003e 0, so B(x) = (-Im(nc)) p(x) has the SAME sign as p(x). Now p(x) = prod(x - lambda_i) has sign (-1)^n for x \u003c lambda_1, changes sign at each lambda_i, and is positive for x \u003e lambda_n. At x = lambda_i, B(lambda_i) = 0 and A(lambda_i) = p'(lambda_i) != 0 (alternating sign). Between consecutive lambda_i, B(x) != 0 (since p(x) != 0 there), so f(x) != 0 on R (confirming no real roots). The argument of f(x) as x traverses [-R, R]: for x \u003c\u003c -R, f(x) approx (-nc) x^n, so arg(f(x)) approx arg(-nc) + n arg(x) = arg(-nc) + n pi (since x \u003c 0, arg(x) = pi). For x \u003e\u003e R, f(x) approx (-nc) x^n, so arg(f(x)) approx arg(-nc) (since arg(x) = 0). The total change in argument along [-R, R] is [arg(-nc)] - [arg(-nc) + n pi] = -n pi. BUT we must track the argument change more carefully through the sign changes of B(x). As x increases through each lambda_i, B(x) = (-Im(nc)) p(x) changes sign (since p changes sign at each root). The function f(x) traces a curve in C that crosses the real axis at each lambda_i (since B(lambda_i) = 0) and the crossing direction is determined by the signs of A(lambda_i) = p'(lambda_i) and the sign change of B. At lambda_i: A(lambda_i) = p'(lambda_i) has sign (-1)^{n-i}. B changes from sign(p(x)) for x \u003c lambda_i to sign(p(x)) for x \u003e lambda_i, i.e., B changes sign. So f(x) crosses the real axis at A(lambda_i) with B going from one sign to the other. The argument change at each crossing contributes +pi or -pi depending on the direction. Since B(x) \u003e 0 for x in (lambda_n, +infty) (because p(x) \u003e 0 and -Im(nc) \u003e 0), and B alternates sign on the intervals between consecutive lambda_i, the curve f(x) alternates between upper and lower half-planes. Starting from x = +infty (B \u003e 0, upper half-plane) and going to x = -infty, the curve crosses the real axis n times (at lambda_n, lambda_{n-1}, ..., lambda_1), with total argument change = -n pi. TOTAL: (n pi + (-n pi))/(2 pi) = 0/2pi = 0?? That gives 0 zeros in C^+. This is WRONG. RE-EXAMINATION: The error is in the semicircle contribution. On the semicircle w = Re^{i theta} with theta from pi to 0 (as part of the COUNTERCLOCKWISE contour, the real segment goes from -R to R, then the semicircle goes from R back to -R, i.e., theta from 0 to pi). Let me redo: the contour goes [-R, R] (left to right on real axis) then semicircle from R to -R (theta: 0 to pi). On the semicircle (theta: 0 to pi): arg(f) changes by approx n pi (from arg(-nc) to arg(-nc) + n pi). On real axis (x: -R to R): arg(f) changes from arg(-nc) + n pi (at x = -R) to arg(-nc) (at x = R), but with n crossings of the real axis in between. Total change = arg(-nc) - (arg(-nc) + n pi) = -n pi in the SMOOTH part, but each crossing of the real axis contributes an additional +pi or -pi. Since f(x) crosses from B \u003e 0 to B \u003c 0 at each lambda_i where p'(lambda_i) has sign (-1)^{n-i}, we need to count: each crossing where the curve goes from upper half-plane to lower half-plane crossing through a POSITIVE real value contributes -pi, and through a NEGATIVE real value contributes +pi (and vice versa for lower to upper). DETAILED TRACKING: For x slightly less than lambda_n: B(x) = (-Im(nc)) p(x) where p(x) \u003c 0 for x in (lambda_{n-1}, lambda_n) (since p changes sign at lambda_n with p \u003e 0 for x \u003e lambda_n). So B \u003c 0 just below lambda_n, and B \u003e 0 just above lambda_n. The crossing at lambda_n goes from B \u003c 0 (lower half-plane) to B \u003e 0 (upper half-plane), with A(lambda_n) = p'(lambda_n) \u003e 0. This is a counterclockwise crossing of the positive real axis, contributing +pi to the argument. Similarly tracking each crossing: at lambda_i, A has sign (-1)^{n-i} and B goes from sign (-1)^{n-i} (below) to sign (-1)^{n-i-1} (above). Each such crossing contributes +pi to the total argument change. So the n crossings contribute +n pi total. Adding: argument change on real segment = -n pi + n pi = 0. Adding semicircle: 0 + n pi = n pi. Number of zeros = n pi / (2 pi) = n/2. This is still not an integer for odd n! RESOLUTION: The issue is that the contour [-R, R] passes through the points lambda_i where f is nonzero but B = 0 (the curve touches the real axis). These are NOT poles or zeros, so the argument principle applies without modification. The argument change computation must be done more carefully using the actual winding of the curve f(Gamma_R) around the origin. Let me use a COMPLETELY DIFFERENT AND CLEAN approach.","inference":"assumption","workflow_state":"available","epistemic_state":"pending","taint_state":"unresolved","content_hash":"5f6f615e3a921c01d1379502532937deb56e8531872572762857efdf6a64cded","created":"2026-02-08T10:19:21.290886463Z","claimed_at":"0001-01-01T00:00:00Z"}}